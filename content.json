{"meta":{"title":"止雨","subtitle":"","description":"我忘却了所有悲剧，所见皆是奇迹。","author":"止雨","url":"https://stoprain0.github.io.git","root":"/"},"pages":[{"title":"关于","date":"2021-09-20T02:27:44.000Z","updated":"2021-09-20T12:56:59.696Z","comments":true,"path":"about/index.html","permalink":"https://stoprain0.github.io.git/about/index.html","excerpt":"","text":"⏮⏪⏸⏭⏩ 💖以此博客记录我的学习笔记。"}],"posts":[{"title":"C语言","slug":"C语言校园导航系统","date":"2021-10-17T16:20:51.008Z","updated":"2021-10-19T15:40:27.779Z","comments":true,"path":"2021/10/18/C语言校园导航系统/","link":"","permalink":"https://stoprain0.github.io.git/2021/10/18/C%E8%AF%AD%E8%A8%80%E6%A0%A1%E5%9B%AD%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"#include&lt;stdio.h> // 无向带权图 #include&lt;stdlib.h>#include&lt;string.h>#define INF 32767 // 表示无穷大，表示该路不可通过 #define MAXV 30 // 可更改后的最大顶点数 #define MAX 40 #define Vertenum 18 //key 为顶点个数 18 个点 typedef struct // 顶点信息 &#123; int no; // 景点的编号 char name[20]; // 景点的名称 char introduction[150]; // 景点的介绍 &#125;VertexType;typedef struct // 图结构信息&#123; int Vnum,Arcnum; // 顶点数和边数 VertexType vexs[MAXV]; // 顶点（数组） int edges[Vertenum+1][Vertenum+1]; // 邻接矩阵 0 的行和列空出来，因为图是从 1 开始 &#125;MGraph;void mainwork(); // 主系统界面 void Filemenu(); // 文件系统界面 // 全局变量MGraph map; // 图变量（大学校园） int d[30];int visited[30];int shortest[MAXV][MAXV];// 定义全局变量存储最小路径 int path[MAXV][MAXV];// 定义存储路径 MGraph initialize()// 图初始化 &#123; int i=0,j=0; MGraph g; g.Vnum=18; // 顶点个数 g.Arcnum=28; // 边的个数 for(i=1;i&lt;=Vertenum;i++) // 依次设置顶点编号 g.vexs[i].no=i; // 依次输入顶点信息 strcpy (a,b) 将字符串 b 复制给字符串 a strcpy(g.vexs[1].name,\"北门\");strcpy(g.vexs[1].introduction,\"北区北方向的大门\"); //strcpy(g.vexs[11].super_introduction,\"\\n\"); strcpy(g.vexs[2].name,\"工会\");strcpy(g.vexs[2].introduction,\"不知道干啥的\"); strcpy(g.vexs[3].name,\"教工住宅区A\");strcpy(g.vexs[3].introduction,\"教职工住的地方\"); strcpy(g.vexs[4].name,\"篮球场\");strcpy(g.vexs[4].introduction,\"学生的室外篮球场\"); strcpy(g.vexs[5].name,\"英东实验楼\");strcpy(g.vexs[5].introduction,\"内设有多种实验室，实验课一般在此上课\"); strcpy(g.vexs[6].name,\"教学楼\");strcpy(g.vexs[6].introduction,\"学生上课的地方\"); strcpy(g.vexs[7].name,\"仲恺像\");strcpy(g.vexs[7].introduction,\"纪念廖仲恺先生而设立的雕像\"); strcpy(g.vexs[8].name,\"停车场\");strcpy(g.vexs[8].introduction,\"停车的地方\"); strcpy(g.vexs[9].name,\"北区学生公寓\");strcpy(g.vexs[9].introduction,\"学生宿舍\"); strcpy(g.vexs[10].name,\"廖仲恺何香凝纪念馆\");strcpy(g.vexs[10].introduction,\"纪念廖仲恺何香凝先生的地方\"); strcpy(g.vexs[11].name,\"乐干楼\");strcpy(g.vexs[11].introduction,\"不知道干什么的地方\"); strcpy(g.vexs[12].name,\"教工住宅区B\");strcpy(g.vexs[12].introduction,\"教职工住的地方\"); strcpy(g.vexs[13].name,\"何香凝艺术设计学院\");strcpy(g.vexs[13].introduction,\"搞艺术的\"); strcpy(g.vexs[14].name,\"10栋\");strcpy(g.vexs[14].introduction,\"学生宿舍\"); strcpy(g.vexs[15].name,\"北区饭堂\");strcpy(g.vexs[15].introduction,\"学生吃饭的地方\"); strcpy(g.vexs[16].name,\"操场\");strcpy(g.vexs[16].introduction,\"军训，上体育课的地方\"); strcpy(g.vexs[17].name,\"北区篮球场\");strcpy(g.vexs[17].introduction,\"室内篮球场\"); strcpy(g.vexs[18].name,\"南门\");strcpy(g.vexs[18].introduction,\"南方向的出口\"); for(i=1;i&lt;=Vertenum;i++) for(i=1;i&lt;=Vertenum;i++) for(j=1;j&lt;=Vertenum;j++) g.edges[i][j]=INF;// 先初始化图的邻接矩阵 // 对 28 条边赋权重 g.edges[1][4]=10; g.edges[1][5]=45; g.edges[1][9]=35; g.edges[1][10]=10; g.edges[1][13]=40; g.edges[2][3]=7; g.edges[2][4]=8; g.edges[3][4]=8; g.edges[3][5]=30; g.edges[5][6]=8; g.edges[5][9]=20; g.edges[6][7]=8; g.edges[6][16]=35; g.edges[7][8]=6; g.edges[8][16]=26; g.edges[8][18]=30; g.edges[9][16]=28; g.edges[10][11]=8; g.edges[10][12]=10; g.edges[11][12]=5; g.edges[12][15]=20; g.edges[13][14]=8; g.edges[13][15]=8; g.edges[14][15]=6; g.edges[14][16]=25; g.edges[15][16]=30; g.edges[16][17]=5; g.edges[16][18]=30; for(i=1;i&lt;=Vertenum;i++)// 对称赋值（无向图需要对称赋值） for(j=1;j&lt;=Vertenum;j++) g.edges[j][i]=g.edges[i][j]; return g;&#125;//initialize//2. 查找景点在图中的序号int locatevex(MGraph g,int v)//locatevex&#123; int i; for(i=1;i&lt;=g.Vnum;i++) if(v==g.vexs[i].no) return i;// 找到，返回顶点序号 i return -1;// 没有找到这个顶点 &#125; //3. 查找并输出序号为 m,n 景点间的长度不超过 8 个景点的路径 void thepath(MGraph g,int m,int n,int k)&#123; int s,t=k+1,length=0;//t 用于存放路径上下一个顶点对应的 d [] 数组元素的下标 if(d[k]==n&amp;&amp;k&lt;8)// 若 d [k] 是终点 n 且景点个数 & lt;=8, 则输出该路径 &#123; for(s=0;s&lt;k;s++)// 计算路径长度 &#123; length=length+g.edges[d[s]][d[s+1]]; &#125; if(length&lt;=100)// 打印路径长度小于定长的路径 &#123; for(s=0;s&lt;k;s++)// 输出该路径。s=0 时为起点 m &#123; printf(\"%d%s--->\",d[s],g.vexs[d[s]].name); &#125; printf(\"%d%s \",d[s],g.vexs[d[s]].name);// 输出最后一个景点名（即顶点 n 的名字，此时 s==k） printf(\"总路线长为%d米\\n\\n\",length); &#125; &#125; else &#123; s=1; while(s&lt;=g.Vnum)// 从第 m 个顶点，试探所有顶点是否有路径 &#123; if((g.edges[d[k]][s]&lt;INF)&amp;&amp;(visited[s]==0))// 顶点 m 到顶点 s 有边 (权值不为无穷大)，且未被访问 &#123; visited[s]=1; d[k+1]=s;// 存储顶点编号 thepath(g,m,n,t); visited[s]=0;// 将找到的路径上顶点的访问标志重新设置为 0，以用于试探新的路径 &#125; s++;// 试探从下一个顶点 s 开始是否有到终点的路径 &#125; &#125; &#125; //4. 查找两景点间的景点的所有路径int allpath(MGraph g)&#123; int k,i,j,m,n; printf(\"\\n\\n请输入您想要查询的两个景点的编号：\\n\\n\"); scanf(\"%d%d\",&amp;i,&amp;j);printf(\"\\n\\n\"); m=locatevex(g,i);//locatevex 确定该顶点是否存在。若存在，返回该顶点编号。 n=locatevex(g,j); d[0]=m;// 存储路径起点 m（int d [] 数组是全局变量） for(k=0;k&lt;Vertenum;k++)// 全部顶点访问标志初值设为 0 visited[k]=0; visited[m]=1;// 第 m 个顶点访问标志设置为 1 thepath(g,m,n,0);// 调用程序。k=1，对应起点 d [1]==m。k 为 d [] 数组下标 return 1;&#125;void Dispath(MGraph g,int dist[],int path[],int s[],int v)&#123; int i,j,k; int apath[MAXV],d; for(i=1;i&lt;=g.Vnum;i++) if(s[i]==1&amp;&amp;i!=v) &#123; printf(\" 从%s到%s的最短路径长度为:%d\\t路径为：\",g.vexs[v].name,g.vexs[i].name,dist[i]); d=0;apath[d]=i; k=path[i]; if(k==-1) printf(\"无路径\\n\"); else &#123; while(k!=v) &#123; d++; apath[d]=k; k=path[k]; &#125; d++;apath[d]=v; printf(\"%d\",apath[d]); for(j=d-1;j>=0;j--) printf(\" %d \",apath[j]); printf(\"\\n\"); &#125; &#125; &#125;void Dijkstra(MGraph g)&#123; int v; // 出发点 int dist[MAXV],path[MAXV]; //dist 记录权值，path 记录上一点的下标方便返回 int s[MAXV]; //s 集合，值为 1 即在 s 中，不是 1 即为未访问 int mindis,i,j,u; printf(\"\\n请输入一个起始景点的编号：\"); scanf(\"%d\",&amp;v); printf(\"\\n\\n\"); while(v&lt;0||v>Vertenum) &#123; printf(\"\\n您输入的景点编号不存在\\n\"); printf(\"请重新输入：\"); scanf(\"%d\",&amp;v); &#125; for(i=1;i&lt;=g.Vnum;i++) &#123; dist[i]=g.edges[v][i]; s[i]=0; if(g.edges[v][i]&lt;INF) path[i]=v; else path[i]=-1; &#125; s[v]=1;path[v]=0; for(i=1;i&lt;=g.Vnum;i++) &#123; mindis=INF; for(j=1;j&lt;=g.Vnum;j++) if(s[j]==0&amp;&amp;dist[j]&lt;mindis) &#123; u=j; mindis=dist[j]; &#125; s[u]=1; for(j=1;j&lt;=g.Vnum;j++) if(s[j]==0) if(g.edges[u][j]&lt;INF&amp;&amp;dist[u]+g.edges[u][j]&lt;dist[j]) &#123; dist[j]=dist[u]+g.edges[u][j]; path[j]=u; &#125; &#125; Dispath(g,dist,path,s,v); &#125;// 菜单 void menu()&#123; printf(\" ┌──────────────────────────────────────────────────────┐\\n\"); printf(\" │ ╭═══════════════════════════════════════════════╮ │\\n\"); printf(\" │ ││ 欢 迎 使 用 校 园 导 游 系 统 ││ │\\n\"); printf(\" │ ╰ ═══════════════════════════════════════════════ ╯ │\\n\"); printf(\" │ 欢迎来到 │\\n\"); printf(\" │ 仲恺农业工程学院学院 │\\n\"); printf(\" │ 菜 单 选 择 │\\n\"); printf(\" │ *************************************************** │\\n\"); printf(\" │ * 1.菜单 ** 2.查看游览路线（迪）* │\\n\");// 学校景点介绍 printf(\" │ *************************************************** │\\n\"); printf(\" │ * 3.查询景点间最短路径 ** 4.查询景点间所有路径* │\\n\"); printf(\" │ *************************************************** │\\n\"); printf(\" │ * 5.学校景点介绍 ** 6.景点信息查询 * │\\n\");// printf(\" │ *************************************************** │\\n\"); printf(\" │ * 7.学校地图 ** 8.更改图信息 * │\\n\"); printf(\" │ *************************************************** │\\n\"); printf(\" │ * 0.退出 ** 9.保存地图信息 * │\\n\"); printf(\" │ *************************************************** │\\n\"); printf(\" └──────────────────────────────────────────────────────┘\\n\");&#125;// 以下是修改图的相关信息。包括建图、更新信息、删除、增加结点和边//6. 重新构造图 int creatgraph(MGraph *g)&#123; int i,j,m,n,v0,v1,distance; printf(\"请输入图的顶点数和边数: \\n\"); scanf(\"%d %d\",&amp;g->Vnum,&amp;g->Arcnum); printf(\"下面请输入景点的信息： \\n\"); for(i=1;i&lt;=g->Vnum;i++) &#123; printf(\"请输入景点的编号：\"); scanf(\"%d\",&amp;g->vexs[i].no); printf(\"\\n请输入景点的名称：\"); scanf(\"%s\",&amp;g->vexs[i].name); printf(\"\\n请输入景点的简介：\"); scanf(\"%s\",&amp;g->vexs[i].introduction); &#125; for(i=1;i&lt;=g->Vnum;i++) for(j=1;j&lt;=g->Vnum;j++)// 权值全部初始化为无穷 g->edges[i][j]=INF; printf(\"下面请输入图的边的信息：\\n\"); for(i=1;i&lt;=g->Vnum;i++) &#123; printf(\"\\n第%d条边的起点 终点 长度为：\",i); scanf(\"%d %d %d\",&amp;v0,&amp;v1,&amp;distance); m=locatevex(map,v0);// 判断一下点是否存在，存在就返回位置 n=locatevex(map,v1); if(m>0&amp;&amp;n>0) &#123; g->edges[m][n]=distance; g->edges[n][m]=g->edges[m][n]; &#125; &#125; return 1;&#125;//7. 更新图的部分信息。返回值：1*** 比如某个信息输错了，需要改 int newgraph(MGraph *g)&#123; int changenum; int i,m,n,t,distance,v0,v1; printf(\"\\n下面请输入您要修改的景点的个数：\\n\"); scanf(\"%d\",&amp;changenum); while(changenum&lt;0||changenum>Vertenum) &#123; printf(\"\\n输入错误！请重新输入\"); scanf(\"%d\",&amp;changenum); &#125; for(i=0;i&lt;changenum;i++) &#123; printf(\"\\n请输入景点的编号：\"); scanf(\"%d\",&amp;m); t=locatevex(map,m); printf(\"\\n请输入修改后景点的名称:\"); scanf(\"%s\",&amp;g->vexs[t].name); printf(\"\\n请输入修改后景点的简介:\"); scanf(\"%s\",&amp;g->vexs[t].introduction); &#125; printf(\"\\n下面请输入您要更新的边数\"); scanf(\"%d\",&amp;changenum); while(changenum&lt;0||changenum>Vertenum) &#123; printf(\"\\n输入错误！请重新输入\"); scanf(\"%d\",&amp;changenum); &#125; if(changenum!=0) printf(\"\\n下面请输入更新边的信息：\\n\"); for(i=1;i&lt;=changenum;i++) &#123; printf(\"\\n修改的第%d条边的起点 终点 长度为：\",i); scanf(\"%d %d %d\",&amp;v0,&amp;v1,&amp;distance); m=locatevex(map,v0); n=locatevex(map,v1); if(m>=0&amp;&amp;n>=0) &#123; g->edges[m][n]=distance; g->edges[n][m]=g->edges[m][n]; &#125; &#125; return 1;&#125; //8. 增加一条边。返回值：1*** int enarc(MGraph *g)&#123; int m,n,distance; printf(\"\\n请输入边的起点和终点编号，权值：\"); scanf(\"%d %d %d\",&amp;m,&amp;n,&amp;distance); while(m&lt;0||m>g->Vnum||n&lt;0||n>g->Vnum) &#123; printf(\"输入错误，请重新输入：\"); scanf(\"%d %d\",&amp;m,&amp;n); &#125; if(locatevex(map,m)&lt;0) &#123; printf(\"此节点%d已删除\",m); return 1; &#125; if(locatevex(map,n)&lt;0) &#123; printf(\"此节点%d已被删除\",n); return 1; &#125; g->edges[m][n]=distance;// 在邻接矩阵中多加一个值 g->edges[n][m]=g->edges[m][n]; g->Arcnum --;// 图中边数 + 1 return 1;&#125;//9. 增加一个结点。返回值：1*** int envex(MGraph *g)&#123; int i; g->Vnum++;// 顶点个数 + 1 printf(\"请输入您要增加结点的信息：\"); printf(\"\\n编号：\"); scanf(\"%d\",&amp;g->vexs[g->Vnum].no); printf(\"名称：\"); scanf(\"%s\",&amp;g->vexs[g->Vnum].name); printf(\"简介：\"); scanf(\"%s\",&amp;g->vexs[g->Vnum].introduction); for(i=1;i&lt;=g->Vnum;i++) &#123; g->edges[g->Vnum][i]=INF; g->edges[i][g->Vnum]=INF; &#125; return 1;&#125; //10. 删除图的一个顶点。返回值：1*** int delvex(MGraph *g) &#123; int i=0,j; int m,v; if(g->Vnum&lt;=0) &#123; printf(\"图中已无顶点\"); return 1; &#125; printf(\"\\n下面请输入您要删除的景点编号：\"); scanf(\"%d\",&amp;v); while(v&lt;0||v>Vertenum) &#123; printf(\"\\n输入错误！请重新输入:\"); scanf(\"%d\",&amp;v); &#125; m=locatevex(map,v); if(m&lt;0) &#123; printf(\"此顶点%d已删除\\n\",v); return 1; &#125; for(i=m;i&lt;=g->Vnum-1;i++) for(j=1;j&lt;=g->Vnum;j++)// 将二维数组中的第 m+1 行依次向前移动一行（删除第 m 行） g->edges[i][j]=g->edges[i+1][j]; for(i=m;i&lt;=g->Vnum-1;i++) for(j=1;j&lt;=g->Vnum;j++)// 将二维数组中的第 m+1 列依次向前移动一列（删除第 m 列） g->edges[j][i]=g->edges[j][i+1]; g->vexs[v].no=-1;// 表示此点已删除，后期打印也不会显示该点 g->Vnum--;// 顶点个数 - 1 return 1;&#125;//11. 删除图的一条边。返回值：1*** int delarc(MGraph *g)&#123; int m,n,v0,v1; if(g->Vnum&lt;=0) &#123; printf(\"图中已无边，无法删除。\"); return 1; &#125; printf(\"\\n下面请输入您要删除的边的起点和终点编号：\"); scanf(\"%d %d\",&amp;v0,&amp;v1); m=locatevex(map,v0); if(m&lt;0) &#123; printf(\"此%d顶点已删除\",v0); return 1; &#125; n=locatevex(map,v1); if(n&lt;0) &#123; printf(\"此%d顶点已删除\",v1); return 1; &#125; g->edges[m][n]=INF;// 将删掉的边的权值改为无穷 g->edges[n][m]=INF; g->Arcnum --;// 图中边数减 1 return 1;&#125;//12. 输出图的邻接矩阵的值 *** void printmatrix(MGraph g)&#123; int i,j,k=0; for(i=1;i&lt;=Vertenum;i++) &#123; if(g.vexs[i].no!=-1) printf(\"%6d\",i);// 横着的标号 1 到 11 &#125; printf(\"\\n\"); for(i=1;i&lt;=g.Vnum;i++) &#123; for(j=1;j&lt;=g.Vnum;j++) &#123; if(g.edges[i][j]==INF) printf(\" *#@* \"); else printf(\"%6d\",g.edges[i][j]); k++; if(k%g.Vnum==0) printf(\"\\n\"); &#125; &#125; &#125; //13. 图的操作主调函数。返回值：1*** int changegraph(MGraph *g)&#123; int choice; printf(\"(1)重新建图 (2)删除结点 (3)删除边\\n\"); printf(\"(4)增加结点 (5)增加边 (6)更新信息\\n\"); printf(\"(7)打印邻接矩阵 (8)返回上一级\\n\"); do &#123; printf(\"请输入您的选择：\"); scanf(\"%d\",&amp;choice); switch(choice) &#123; case 1:creatgraph(g);break; case 2:delvex(g);break; case 3:delarc(g);break; case 4:envex(g);break; case 5:enarc(g);break; case 6:newgraph(g);break; case 7:printmatrix(map);break; case 8:system(\"cls\");menu();return 1;//break; default:printf(\"未找到该功能，请输入有效选项！\\n\");break; &#125; &#125;while(choice);&#125;int administrator_login() &#123; int i; int a[6]=&#123;1,2,3,4,5,6&#125;,b[6]; //for(i=0;i&lt;6;i++) //printf(\"%d \",a[i]); printf(\"\\n请输入6位密码(每输入一位密码间隔一个空格)：\\n\"); for(i=0;i&lt;6;i++) scanf(\"%d\",&amp;b[i]); for(i=0;i&lt;6;i++) &#123; if(a[i]!=b[i]) &#123; printf(\"密码错误!自动返回上一级\\n\"); menu(); return 0; &#125; &#125; printf(\"密码正确，登陆成功！\\n\\n\"); changegraph(&amp;map);&#125;//14. 查询两景点间的最短路径（floyd 算法）void floyd(MGraph g)// 一种暴力破解获取最短路径的算法 &#123; int i,j,k; for(i=1;i&lt;=Vertenum;i++)// 将图的邻接矩阵赋值给 shortest 二维数组，将矩阵 path 全部初始化为 - 1 &#123; for(j=1;j&lt;=Vertenum;j++) &#123; shortest[i][j]=g.edges[i][j]; path[i][j]=j; &#125; &#125; int i1,j1,k1=0; for(i1=1;i1&lt;=Vertenum;i1++) printf(\"%6d\",i1);// 横着的标号 1 到 11 printf(\"\\n\"); for(i1=1;i1&lt;=Vertenum;i1++) &#123; printf(\"%d\",i1);// 竖着的标号 1 到 11 for(j1=1;j1&lt;=Vertenum;j1++) &#123; printf(\"%6d\",path[i1][j1]); k1++; if(k1%Vertenum==0) printf(\"\\n\"); &#125; &#125; printf(\"\\n\\n\\n\"); for(k=1;k&lt;=Vertenum;k++)// 核心操作，完成了以 k 为中间点对所有的顶点对（i,j）进行检测和修改 &#123; for(i=1;i&lt;=Vertenum;i++) &#123; for(j=1;j&lt;=Vertenum;j++) &#123; if(shortest[i][j]>shortest[i][k]+shortest[k][j]) &#123; shortest[i][j]=shortest[i][k]+shortest[k][j]; path[i][j]=path[i][k];// 记录一下所走的路 //P 数组用来存放前驱顶点 &#125; &#125; &#125; &#125;&#125;void printf_Pshuzu()&#123; int i,j,k=0; for(i=1;i&lt;=Vertenum;i++) printf(\"%6d\",i);// 横着的标号 0 到 11 printf(\"\\n\"); for(i=1;i&lt;=Vertenum;i++) &#123; printf(\"%d\",i);// 竖着的标号 0 到 11 for(j=1;j&lt;=Vertenum;j++) &#123; printf(\"%6d\",path[i][j]); k++; if(k%Vertenum==0) printf(\"\\n\"); &#125; &#125; printf(\"\\n\\n\\n\");&#125;// 打印出最短路径 void display(MGraph g,int i,int j)&#123; int a,b; a=i;b=j; printf(\"您要查询的两景点间最短路径：\\n\\n\"); printf(\"%d%s\",a,g.vexs[a].name); while(path[i][j]!=b) &#123; printf(\"-->%d%s\",path[i][j],g.vexs[path[i][j]].name); i=path[i][j]; &#125; printf(\"-->%d%s\\n\\n\",b,g.vexs[b].name); printf(\"%s-->%s的最短路径是：%d 米。\\n\\n\",g.vexs[a].name,g.vexs[b].name,shortest[a][b]);&#125;// 任意两点间最短距离（弗洛伊德算法）int shortst_distance(MGraph g) &#123; int i,j; printf(\"请输入要查询的两个景点的数字编号（1->11）中间用空格间隔开。\\n\"); scanf(\"%d %d\",&amp;i,&amp;j); if(i>Vertenum||i&lt;0||j>Vertenum||j&lt;0) &#123; printf(\"输入信息错误！\\n\\n\"); printf(\"请输入要查询的两个景点的数字编号（1->11）中间用空格间隔开。\\n\"); scanf(\"%d %d\",&amp;i,&amp;j); &#125; else &#123; floyd(g);printf_Pshuzu(); display(g,i,j); &#125; return 1;&#125;//15. 查询景点的信息void query_information(MGraph g)&#123; int k; printf(\"\\n请输入要查询的景点编号：\"); scanf(\"%d\",&amp;k); while(k&lt;=0||k>Vertenum) &#123; printf(\"\\n您所输入的景点编号不存在！\"); printf(\"\\n请重新输入景点编号：\"); scanf(\"%d\",&amp;k); &#125; printf(\"\\n\\n编号：%-4d\\n\",g.vexs[k].no); printf(\"\\n景点名称：%-10s\\n\",g.vexs[k].name); printf(\"\\n详细介绍：%-80s\\n\\n\",g.vexs[k].introduction);&#125;//16. 显示所有景点信息 attractions informationvoid attraction_information(MGraph g) &#123; int i; printf(\" \\n\\n编号 景点名称 简介\\n\"); printf(\"____________________________________________________________________________________________\\n\"); for(i=1;i&lt;=Vertenum;i++) &#123; if(g.vexs[i].no!=-1) printf(\"%-10d%-25s%-80s\\n\",g.vexs[i].no,g.vexs[i].name,g.vexs[i].introduction); //- 左对齐 &#125; printf(\"____________________________________________________________________________________________\\n\");&#125;//17. 海珠区地图void school_map()&#123; printf(\" --------------------------------------------------------海珠北区地图----------------------------------------------------------- \\n\"); printf(\" ----------------------------------------------------------------------------------------------------------------------------- \\n\"); printf(\" \\n\"); printf(\" ______________________________________________________________________________________________ \\n\"); printf(\" | ___________ __________________ | \\n\"); printf(\" | | | | | | \\n\"); printf(\" | | 英 | | | ______________ | \\n\"); printf(\" | | 东 | ********** | 教 | _______ | | || \\n\"); printf(\" | | 实 | * * | 学 | |仲恺 | | 停车场 | || \\n\"); printf(\" | | 验 | * * | 楼 | |__像_| | | 南门 \\n\"); printf(\" | | 楼 | * * | | | | || \\n\"); printf(\" | | | * * | | |____________| || \\n\"); printf(\" ______________________________| | | * * | | | \\n\"); printf(\" |_________ | | ********** | | | \\n\"); printf(\" | | ________________ |_________| |________________| | \\n\"); printf(\" | 工会 | | 教工住宅区 | | \\n\"); printf(\" |_________| |______________| | \\n\"); printf(\" | _______________ ________________ | \\n\"); printf(\" | | | | 北区 | ************************************************ | \\n\"); printf(\" | | 篮球场 | | 学生 | _______________|_ \\n\"); printf(\" | | | | 公寓 | | \\n\"); printf(\" | |_______________| |______________| ____________________________________ | \\n\"); printf(\" | | | | \\n\"); printf(\" || ======================= _____________ ___________ | | | \\n\"); printf(\"北门 ======================= | 何香凝艺术| | | | | | \\n\"); printf(\" || ________________ * | 设计学院 | | 10栋 | | | | \\n\"); printf(\" | | 廖仲恺何香凝 | * |___________| |_________| | 操场 | | \\n\"); printf(\" | |____纪念馆____| * ______________________ | | | \\n\"); printf(\" | __________ * | | | | | \\n\"); printf(\" | | 乐干楼 | * | | |__________________________________| | \\n\"); printf(\" | |__________| * | 北区饭堂 | | | | \\n\"); printf(\" | ________________ * | | | 北区篮球场 | | \\n\"); printf(\" | | 教工住宅区 | * |____________________| | | | \\n\"); printf(\" | |______________| * —————————————————— | \\n\"); printf(\" | | \\n\"); printf(\" |____________________________________________________________________________________________________________|_ \\n\"); printf(\" ================ ======================= ============ \\n\"); &#125;int ReadText(char *filename,int mapflag) // 文件读入 读入地图的基本数据 &#123; if(mapflag==1) &#123; int i=1; MGraph g; FILE *fp; fp=fopen(filename,\"r\"); if(!fp) &#123; printf(\"文件不存在！\\n\"); exit(1); &#125; if(feof(fp)) &#123; printf(\"请先输入数据或写入数据！\\n\"); return 0; &#125; printf(\"读取到的地图信息为：\\n\"); printf(\"\\n\"); fscanf(fp,\"%d%s%s\",&amp;i,&amp;g.vexs[i].name,&amp;g.vexs[i].introduction);// 读入一条记录 fp 自动走到下一行 while(!feof(fp)) &#123; printf(\"%d\\t%9s%50s\\n\",i,g.vexs[i].name,g.vexs[i].introduction); i++; fscanf(fp,\"%d%s%s\",&amp;i,&amp;g.vexs[i].name,&amp;g.vexs[i].introduction);// 读入下一条记录 &#125; fclose(fp); &#125; else &#123; printf(\"请先写入地图数据！\\n\\n\"); Filemenu(); &#125;&#125; void WriteText(char *filename,MGraph g) // 文件输入 写入地图的信息 &#123; FILE *fp; fp=fopen(filename,\"w+\"); int i,j; if(!fp) &#123; printf(\"文件不存在！\\n\"); exit(1); &#125; for(i=1;i&lt;=g.Vnum;i++) fprintf(fp,\"%d\\t%9s%50s\\n\",i,g.vexs[i].name,g.vexs[i].introduction); printf(\"地图信息写入完成！\\n\"); fclose(fp); &#125;int ReadMatrix(char *filename,int matrixflag) // 读入邻接矩阵 &#123; if(matrixflag==1) &#123; int i,j; MGraph g; FILE *fp; fp=fopen(filename,\"r\"); if(!fp) &#123; printf(\"文件不存在！\\n\"); exit(1); &#125; printf(\"\\n\"); printf(\"读取到的邻接矩阵为：\\n\"); for(i=1;i&lt;=Vertenum;i++) &#123; for(j=1;j&lt;=Vertenum;j++) &#123; fscanf(fp,\"%d\",&amp;g.edges[i][j]);// 读入下一条记录 printf(\"%d\\t\",g.edges[i][j]); &#125; printf(\"\\n\"); &#125; fclose(fp); &#125; else &#123; printf(\"请先写入邻接矩阵数据！\\n\\n\"); Filemenu(); &#125; &#125; void WriteMatrix(char *filename,MGraph g) // 写入邻接矩阵 &#123; int i,j; FILE *fp; fp=fopen(filename,\"w+\"); if(!fp) &#123; printf(\"文件不存在！\\n\"); exit(1); &#125; for(i=1;i&lt;=Vertenum;i++) &#123; for(j=1;j&lt;=Vertenum;j++) &#123; fprintf(fp,\"%d\\t\",g.edges[i][j]); &#125; fprintf(fp,\"\\n\"); &#125; printf(\"邻接矩阵写入完成！\\n\"); fclose(fp);&#125;void Filemenu()&#123; printf(\" ┌──────────────────────────────────────────────────────┐\\n\"); printf(\" │ ╭═══════════════════════════════════════════════╮ │\\n\"); printf(\" │ ││ 欢 迎 使 用 文 件 保 存 系 统 ││ │\\n\"); printf(\" │ ╰ ═══════════════════════════════════════════════ ╯ │\\n\"); printf(\" │ │\\n\"); printf(\" │ 菜 单 选 择 │\\n\"); printf(\" │ *************************************************** │\\n\"); printf(\" │ * 1.文件保存菜单 ** 2.写入地图数据 * │\\n\");// 学校景点介绍 printf(\" │ *************************************************** │\\n\"); printf(\" │ * 3.读入地图数据 ** 4.写入邻接矩阵信息 * │\\n\"); printf(\" │ *************************************************** │\\n\"); printf(\" │ * 5.读入邻接矩阵信息 ** 6.返回上一级 * │\\n\");// printf(\" │ *************************************************** │\\n\"); printf(\" │ │\\n\"); printf(\" │ │\\n\"); printf(\" └──────────────────────────────────────────────────────┘\\n\");&#125;// 保存文件信息 void rwFILE(MGraph g)&#123; int mapflag=0,matrixflag=0; // 设置标志，为了实现如果要读入数据得先写入数据 Filemenu(); // 打印界面 int choice; do &#123; printf(\"请输入您的选择：\"); if(scanf(\"%d\",&amp;choice)==1) &#123; switch(choice) &#123; case 1:system(\"cls\");/* 清除屏幕 */Filemenu();break; case 2:system(\"cls\");WriteText(\"地图数据.txt\",map);mapflag=1;break; case 3:system(\"cls\");ReadText(\"地图数据.txt\",mapflag);break; case 4:system(\"cls\");WriteMatrix(\"邻接矩阵.txt\",map);matrixflag=1;break; case 5:system(\"cls\");ReadMatrix(\"邻接矩阵.txt\",matrixflag);break; case 6:system(\"cls\");mainwork();break; default:printf(\"未找到该功能，请输入有效选项！\\n\");break; &#125; &#125; else printf(\"请输入整数！程序结束！\"); &#125;while(choice);&#125; //18. 主要工作函数。操作区用户界面void mainwork()&#123; menu(); int choice; map=initialize(); do &#123; printf(\"请输入您的选择：\"); if(scanf(\"%d\",&amp;choice)==1) &#123; switch(choice) &#123; case 1:system(\"cls\");/* 清除屏幕 */menu();break; case 2:system(\"cls\");Dijkstra(map);break; case 3:system(\"cls\");shortst_distance(map);break; case 4:system(\"cls\");allpath(map);break; case 5:system(\"cls\");attraction_information(map);break; case 6:system(\"cls\");query_information(map);break; case 7:system(\"cls\");school_map();break; case 8:system(\"cls\");administrator_login();break; case 9:system(\"cls\");rwFILE(map);break; case 0:system(\"cls\");printf(\"谢谢使用\\n\");break; default:printf(\"未找到该功能，请输入有效选项！\\n\");break; &#125; &#125; else printf(\"请输入整数！程序结束！\"); &#125;while(choice); &#125;int main()&#123; system(\"color 1f\");// 背景颜色 system(\"mode con: cols=150 lines=130\");// 程序页面长宽 mainwork(); return 0;&#125;","categories":[{"name":"C语言","slug":"C语言","permalink":"https://stoprain0.github.io.git/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://stoprain0.github.io.git/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"HTML","slug":"HTML","date":"2021-10-06T08:32:58.605Z","updated":"2021-10-29T03:02:27.646Z","comments":true,"path":"2021/10/06/HTML/","link":"","permalink":"https://stoprain0.github.io.git/2021/10/06/HTML/","excerpt":"","text":"时间：2021/10/7 学习 HTML # HTML Hyper Text Markup Language 超文本标记语言 # 一、HTML 基础 # 1. HTML 基本结构 - 网页结构主体如下： &lt;!DOCTYPE html> &lt;html lang=\"en\">&lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title>&lt;/head>&lt;body>&lt;/body>&lt;/html> HTML 注释 快捷键 CTRL + / &lt;!-- --> 里面放注释的内容&lt;!DOCTYPE html> &lt;!--DOCTYPE: 告诉浏览器，我们使用的是什么规范 -->&lt;html lang=\"en\"> &lt;!-- head 标签代表网页头部 -->&lt;head> &lt;!-- meta 描述性标签，它用来描述我们网站的一些信息 --> &lt;meta charset=\"UTF-8\"> &lt;!-- title 标签代表网页标题 --> &lt;title>Title&lt;/title>&lt;/head> &lt;!-- body 标签代表网页主体 -->&lt;body>&lt;/body>&lt;/html> 描述关键词 &lt;meta name=&quot;keywords&quot; content=&quot;HTML&quot;&gt; 描述介绍 &lt;meta name=\"description\" content=\"来这里可以学习HTML\">&lt;body> Hello World!&lt;/body> # 2. 网页基本标签 标题标签 段落标签 换行标签 水平线标签 字体样式标签 注释和特殊符号 标题标签 &lt;!-- 标题标签 -->&lt;h1>一级标题&lt;/h1>&lt;h2>二级标题&lt;/h2>&lt;h3>三级标题&lt;/h3>&lt;h4>四级标题&lt;/h4>&lt;h5>五级标题&lt;/h5>&lt;h6>六级标题&lt;/h6> 段落标签 &lt;!-- 段落标签 --> &lt;p>断章&lt;/p>&lt;p>[ 现代 ] 卞之琳&lt;/p>&lt;p>你站在桥上看风景，&lt;/p>&lt;p>看风景的人在楼上看你。&lt;/p>&lt;p>明月装饰了你的窗子，&lt;/p>&lt;p>你装饰了别人的梦。&lt;/p> 换行标签 &lt;!--换行标签--&gt; 断章&lt;br/&gt; [ 现代 ] 卞之琳&lt;br/&gt; 你站在桥上看风景，&lt;br/&gt; 看风景的人在楼上看你。&lt;br/&gt; 明月装饰了你的窗子，&lt;br/&gt; 你装饰了别人的梦。&lt;br/&gt; 水平线标签 &lt;!-- 水平线标签 -->&lt;hr/> 字体样式标签 &lt;!--字体样式标签--&gt; 粗体：&lt;strong&gt;i love you&lt;/strong&gt; 斜体：&lt;em&gt;i love you&lt;/em&gt; 注释和特殊符号 &lt;!--这是注释--&gt; &lt;!--特殊符号--&gt; 空 格 空&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;格 &lt;br/&gt; 大于号&amp;gt; &lt;br/&gt; 小于号&amp;lt; &lt;br/&gt; 版权符号&amp;copy; &lt;br/&gt; # 3. 图像标签 &lt;img src=\"../resources/image/1.jpg\" alt=\"头像\"> alt 标签：图片无法正常显示时，显示文字描述 &lt;img src=\"../resources/image/2.jpg\" alt=\"头像\"> &lt;img src=&quot;../resources/image/1.jpg&quot; alt=&quot;头像&quot; title=&quot;鼠标悬停时显示的文字&quot;&gt; &lt;img src=&quot;../resources/image/1.jpg&quot; alt=&quot;头像&quot; title=&quot;鼠标悬停时显示的文字&quot; width=&quot;300&quot; height=&quot;300&quot;&gt; 还可以设置图片宽和高等等… # 4. 链接标签 文本超链接 &lt;!-- a 标签 href： 必填，表示要跳转到那个页面 -->&lt;a href=\"图像标签.html\">我的头像&lt;/a>&lt;a href=\"https://www.baidu.com/\">百度&lt;/a> 图像超链接 将图片标签嵌入链接标签中 &lt;a href=\"https://www.baidu.com/\">&lt;img src=\"../resources/image/1.jpg\" alt=\"头像\" title=\"鼠标悬停时显示的文字\" width=\"300\" height=\"300\">&lt;/a> &lt;a href=\"#\" target=\"_blank\">在新页面打开&lt;/a>&lt;a href=\"#\" target=\"_self\">在当前页面打开&lt;/a> 锚链接 &lt;!-- 使用 name 作为标记 -->&lt;a name=\"top\">顶部&lt;/a>---------------------------------------&lt;!-- #加标记名 -->&lt;a href=\"#top\">回到顶部&lt;/a> 多应用于页面的跳转，如目录 功能性链接 &lt;!--功能性链接 邮件链接 mailto:+邮箱地址 --&gt; &lt;a href=&quot;mailto:2304465670@qq.com&quot;&gt;点击联系我&lt;/a&gt; 可以打开邮箱 # 5. 行内标签和块元素 块元素 无论内容多少，该元素独占一行 如：p、h1-h6… 行内元素 内容撑开宽度，左右都是行内元素的可以排在同一行 如：a、strong、em… &lt;h1>块元素独占一行&lt;/h1> 其他文字无法和块元素在同一行&lt;br>&lt;strong>行内元素可以同一行&lt;/strong> &lt;strong>行内元素可以同一行&lt;/strong> # 6. 列表标签 有序列表 &lt;!-- 无序列表 -->&lt;ol> &lt;li>Java&lt;/li> &lt;li>Pathon&lt;/li> &lt;li>运维&lt;/li> &lt;li>前端&lt;/li> &lt;li>C/C++&lt;/li>&lt;/ol> 无序列表 应用范围：导航，侧边栏… &lt;!-- 无序列表 -->&lt;ul> &lt;li>Java&lt;/li> &lt;li>Pathon&lt;/li> &lt;li>运维&lt;/li> &lt;li>前端&lt;/li> &lt;li>C/C++&lt;/li>&lt;/ul> 定义列表 &lt;!--定义列表 dl:标签 dt:列表名称 dd:列表内容 --&gt; &lt;dl&gt; &lt;dt&gt;学科&lt;/dt&gt; &lt;dd&gt;Java&lt;/dd&gt; &lt;dd&gt;Python&lt;/dd&gt; &lt;dd&gt;运维&lt;/dd&gt; &lt;dd&gt;前端&lt;/dd&gt; &lt;dd&gt;C/C++&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;位置&lt;/dt&gt; &lt;dd&gt;西安&lt;/dd&gt; &lt;dd&gt;新疆&lt;/dd&gt; &lt;/dl&gt; l 多应用于公司网站底部 # 7. 表格标签 &lt;!-- 表格标签行: tr单元格: td-->&lt;table border=\"1px\"> &lt;tr> &lt;td>1-1&lt;/td> &lt;td>1-2&lt;/td> &lt;td>1-3&lt;/td> &lt;td>1-4&lt;/td> &lt;td>1-5&lt;/td> &lt;/tr> &lt;tr> &lt;td>2-1&lt;/td> &lt;td>2-2&lt;/td> &lt;td>2-3&lt;/td> &lt;td>2-4&lt;/td> &lt;/tr> &lt;tr> &lt;td>3-1&lt;/td> &lt;td>3-2&lt;/td> &lt;td>3-3&lt;/td> &lt;td>3-4&lt;/td> &lt;/tr> &lt;table border=\"1px\"> &lt;tr>&lt;!-- colspan 合并列 --> &lt;td colspan=\"4\">1-1&lt;/td> &lt;/tr> &lt;tr>&lt;!-- rowspan 合并行 --> &lt;td rowspan=\"2\">2-1&lt;/td> &lt;td>2-2&lt;/td> &lt;td>2-3&lt;/td> &lt;td>2-4&lt;/td> &lt;/tr> &lt;tr> &lt;td>3-2&lt;/td> &lt;td>3-3&lt;/td> &lt;td>3-4&lt;/td> &lt;/tr> # 8. 媒体元素 视频元素 video &lt;!--src: 资源路劲controls: 控制条autoplay: 自动播放-->&lt;video src=\"https://www.bilibili.com/video/BV14f4y1h7FX?share_source=copy_web\" controls autoplay>&lt;/video> 音频元素 audio &lt;audio src=\"../resources/audio/周杰伦-明明就.flac\" controls autoplay>&lt;/audio> # 二、页面结构分析 &lt;!DOCTYPE html>&lt;html lang=\"en\">&lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>网页结构学习&lt;/title>&lt;/head>&lt;body>&lt;head> &lt;h2>网页头部&lt;/h2>&lt;/head>&lt;section> &lt;h2>网页主体&lt;/h2>&lt;/section>&lt;footer> &lt;h2>网页脚部&lt;/h2>&lt;/footer>&lt;/body>&lt;/html> 网页的大体结构： # 三、iframe 内联框架 &lt;!--src: 引用地址 name: 框架标识名 -->&lt;iframe src=\"path\" name=\"mainFrame\">&lt;/iframe>&lt;iframe src=\"//player.bilibili.com/player.html?aid=290807456&amp;bvid=BV14f4y1h7FX&amp;cid=345163820&amp;page=1\" autoplay scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" > &lt;/iframe> &lt;iframe src=\"https://www.bilibili.com/\" frameborder=\"0\"width=\"800px\" height=\"600px\"> &lt;/iframe> 可以与 a 标签联合使用 # 四、表单语法 # 1. 文本框和单选框 &lt;h1>注册&lt;/h1>&lt;!-- 表单 formaction: 表单提交的位置，可以是网站，也可以是一个请求处理地址method: post,get 提交方式-->&lt;form action=\"我的第一个网页.html\" method=\"get\"> &lt;p>名字：&lt;input type=\"text\" name=\"username\">&lt;/p> &lt;p>密码：&lt;input type=\"password\" name=\"password\">&lt;/p> &lt;p> &lt;input type=\"submit\"> &lt;input type=\"reset\">&lt;/form> get 提交方式：我们可以在 url 中看到提交的信息，不安全，但高效 post 提交方式： 比较安全，可以传输大文件 post 提交方式 表单元素格式 &lt;!-- 文本输入框：input type=\"text\" value=\"默认值\" 默认初始值 maxlength=\"8\" 最长能写几个字符 size=“30” 文本框的长度 --> &lt;p>名字：&lt;input type=\"text\" name=\"username\">&lt;/p>&lt;!-- 密码框： input type=\"password\" --> &lt;p>密码：&lt;input type=\"password\" name=\"password\">&lt;/p>&lt;!-- 单选框标签input type=\"radio\"value: 单选框的值name: 表示分组，相同名字为同一组，就只能选一个--> &lt;p>性别： &lt;input type=\"radio\" value=\"boy\" name=\"sex\">男 &lt;input type=\"radio\" value=\"girl\" name=\"sex\">女 &lt;/p> # 2. 按钮和多选框 多选框 &lt;!-- 多选框 input type=&quot;checkbox&quot; --&gt; &lt;p&gt;爱好： &lt;input type=&quot;checkbox&quot; value=&quot;sleep&quot; name=&quot;hobby&quot;&gt;睡觉 &lt;input type=&quot;checkbox&quot; value=&quot;code&quot; name=&quot;hobby&quot;&gt;敲代码 &lt;input type=&quot;checkbox&quot; value=&quot;chat&quot; name=&quot;hobby&quot;&gt;聊天 &lt;input type=&quot;checkbox&quot; value=&quot;game&quot; name=&quot;hobby&quot;&gt;游戏 &lt;/p&gt; 按钮 &lt;!-- 按钮input type=\"button\" 普通按钮input type=\"image\" 图像按钮input type=\"submit\" 提交按钮input type=\"reset\" 重置--> &lt;p>按钮： &lt;input type=\"button\" name=\"btn1\" value=\"点击变长\"> &lt;input type=\"image\" src=\"../resources/image/1.jpg\" width=\"300px\" height=\"300px\"> &lt;/p> 单选框和多选框：在属性后面加 checked 可以设为默认选中 # 3. 列表框、文本域和文件域 下拉列表 &lt;!-- 下拉框，列表框 --> &lt;p>下拉框： &lt;select name=\"列表名称\" id=\"\"> &lt;option value=\"china\">中国&lt;/option> &lt;option value=\"us\">美国&lt;/option> &lt;option value=\"eth\" selected>瑞士&lt;/option> &lt;option value=\"yingdu\">印度&lt;/option> &lt;/select> &lt;/p> selected 可设为默认值 文本域 &lt;!--文本域 cols=&quot;50&quot; rows=&quot;10&quot;--&gt; &lt;p&gt;反馈： &lt;textarea name=&quot;textarea&quot; cols=&quot;50&quot; rows=&quot;10&quot;&gt;文本内容&lt;/textarea&gt; &lt;/p&gt; 文件域 &lt;!-- 文本域 input type=\"file\"--> &lt;p> &lt;input type=\"file\" name=\"files\"> &lt;input type=\"button\" value=\"上传\" name=\"upload\"> &lt;/p> # 4. 搜索框滑块和简单验证 简单验证 &lt;!-- 邮箱验证 --> &lt;p>邮箱： &lt;input type=\"email\" name=\"email\"> &lt;/p> &lt;!-- URL 验证 --> &lt;p>链接： &lt;input type=\"url\" name=\"url\"> &lt;/p> &lt;!-- 数字验证 step: 增长步数 --> &lt;p>数字： &lt;input type=\"number\" name=\"num\" max=\"100\" min=\"0\" step=\"10\"> &lt;/p> 搜索框滑块 &lt;!-- 滑块 --> &lt;p>音量： &lt;input type=\"range\" name=\"voice\" min=\"0\" max=\"100\" step=\"2\"> &lt;/p>&lt;!-- 搜索框 --> &lt;p> &lt;input type=\"search\" name=\"search\"> &lt;/p> # 五、表单的应用 隐藏域 只读 禁用 隐藏域 hidden &lt;p>密码：&lt;input type=\"password\" name=\"password\" hidden>&lt;/p> 只读 readonly 加了此属性则不可更改对应的标签内容 禁用 disabled 加了此属性则不可使用被禁用的标签 点击文字跳转到相应文本框输入 增强鼠标可用性 &lt;label for=\"mark\">点击跳&lt;/label> &lt;input type=\"text\" id=\"mark\"> # 表单初级验证 placeholder 提示信息 &lt;input type=\"text\" name=\"username\" placeholder=\"请输入名字\"> required 不能为空 &lt;input type=\"password\" name=\"password\" required> pattern 正则表达式 常用的正则表达式_正则表达式大全_脚本之家 (jb51.net) &lt;input type=\"text\" name=\"diyemil\" pattern=\"\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*\">","categories":[{"name":"前端","slug":"前端","permalink":"https://stoprain0.github.io.git/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://stoprain0.github.io.git/tags/HTML/"},{"name":"前端","slug":"前端","permalink":"https://stoprain0.github.io.git/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Java类型转换","slug":"java1","date":"2021-09-22T15:55:32.426Z","updated":"2021-09-22T15:56:56.697Z","comments":true,"path":"2021/09/22/java1/","link":"","permalink":"https://stoprain0.github.io.git/2021/09/22/java1/","excerpt":"","text":"# Java 类型转换 强制类型转换：由高转低 如 int -&gt;byte 自动类型转换 (隐式类型转换)： 1. 不能对布尔值转换 2. 不能把对象类型转换为不相干的类型 3. 在把高容量转换到低容量时，需要强制类型转换 4. 转换的时候可能存在内存溢出，或是精度问题 Java 会把不同的类型先转换为同一类型再去计算，原理类似 C 语言中 int 与 float 类型做运算。 文章源自学习 B 站【狂神说 Java】Java 零基础学习视频通俗易懂","categories":[{"name":"Java系列","slug":"Java系列","permalink":"https://stoprain0.github.io.git/categories/Java%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://stoprain0.github.io.git/tags/Java/"}]},{"title":"git","slug":"git","date":"2021-09-21T15:44:55.758Z","updated":"2021-09-21T15:47:08.178Z","comments":true,"path":"2021/09/21/git/","link":"","permalink":"https://stoprain0.github.io.git/2021/09/21/git/","excerpt":"","text":"# Git 常用命令 仓库 # 在当前目录新建一个 Git 代码库$ git init# 新建一个目录，将其初始化为 Git 代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]例如： 配置 # 显示当前的 Git 配置$ git config --list# 编辑 Git 配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 增加 / 删除文件 # 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交 # 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次 commit 之后的变化，直接到仓库区$ git commit -a# 提交时显示所有 diff 信息$ git commit -v# 使用一次新的 commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息$ git commit --amend -m [message]# 重做上一次 commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支 # 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定 commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个 commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签 # 列出所有 tag$ git tag# 新建一个 tag 在当前 commit$ git tag [tag]# 新建一个 tag 在指定 commit$ git tag [tag] [commit]# 删除本地 tag$ git tag -d [tag]# 删除远程 tag$ git push origin :refs/tags/[tagName]# 查看 tag 信息$ git show [tag]# 提交指定 tag$ git push [remote] [tag]# 提交所有 tag$ git push [remote] --tags# 新建一个分支，指向某个 tag$ git checkout -b [branch] [tag] 查看信息 # 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示 commit 历史，以及每次 commit 发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个 commit 之后的所有变动，每个 commit 占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个 commit 之后的所有变动，其 \"提交说明\" 必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次 diff$ git log -p [file]# 显示过去 5 次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个 commit 的差异$ git diff --cached [file]# 显示工作区与当前分支最新 commit 之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步 # 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销 # 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个 commit 的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次 commit 保持一致$ git reset --hard# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致$ git reset --hard [commit]# 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个 commit，用来撤销指定 commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他 # 生成一个可供发布的压缩包$ git archive引用 gitee 官方文档自","categories":[{"name":"git","slug":"git","permalink":"https://stoprain0.github.io.git/categories/git/"}],"tags":[{"name":"git学习","slug":"git学习","permalink":"https://stoprain0.github.io.git/tags/git%E5%AD%A6%E4%B9%A0/"},{"name":"git命令语句","slug":"git命令语句","permalink":"https://stoprain0.github.io.git/tags/git%E5%91%BD%E4%BB%A4%E8%AF%AD%E5%8F%A5/"}]},{"title":"","slug":"about","date":"2021-09-20T02:22:59.586Z","updated":"2021-09-20T02:22:18.445Z","comments":true,"path":"2021/09/20/about/","link":"","permalink":"https://stoprain0.github.io.git/2021/09/20/about/","excerpt":"","text":"关于","categories":[],"tags":[]},{"title":"数据库原理及应用","slug":"SQL1","date":"2021-09-19T13:34:41.392Z","updated":"2021-09-22T10:51:59.999Z","comments":true,"path":"2021/09/19/SQL1/","link":"","permalink":"https://stoprain0.github.io.git/2021/09/19/SQL1/","excerpt":"","text":"# 数据库基本操作 发现 SQL 语句对关键字不区分大小写，去了解一下发现 sql 语句大小写的问题： 关键字不区分大小写 例如 select ，from， 大小写均可 标识符区分大小写 例如 表名，列名 标识符如果不加双引号，默认是按大写执行 标识符如果加双引号，则是按原始大小写执行 SQL 语句的书写规范 所有表名，列名全部小写 关键字，内置函数名全部大写 ** 注释使用：**SQL 语句中的单行注释使用 – -- 使用在语句后 SQL 语句中的多行注释采用 /*…*****/ 使用 / 切换数据库： USE+数据库名称 创建表的基本语法： CREATE TABLE 表名( 列名1 数据类型, 列名2 数据类型) 指定字段名为主键 PRIMARY KEY： 指定数据自动增长 IDENTITY (1，1) 第一个参数代表初始值，第二个参数代表增长数。 NOT NULL 则指定对应的值不能为空。 CHECK(列名 =' 值’OR 列名 =‘值’) 限定输入条件 DEFAULT (‘值’) 设默认值 字段名 数据类型 PRIMARY KEY IDENTITY(1，1)建表时如果表名已经存在，则会发生冲突，这时我们可以在建表前加一个判断，然后去解决冲突。 IF EXISTS(SELECT*FROM sys.objects WHERE name='表名'AND TYPE='U' )DROP TABLE 表名–DROP TABLE 表名 删除表（删表仅推荐在数据库入门时使用，因删表操作可能会导致数据丢失） -TYPE=‘U’ 代表为用户自定义的表 # 数据类型： 类型 数据类型举例 说明 Character CHAR(n) , VARCHAR(n) CHAR 固定长度，VARCHAR 可变长度","categories":[{"name":"数据库系列","slug":"数据库系列","permalink":"https://stoprain0.github.io.git/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://stoprain0.github.io.git/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","permalink":"https://stoprain0.github.io.git/tags/SQL/"}]},{"title":"更换主题","slug":"更换主题","date":"2021-09-18T17:09:02.142Z","updated":"2021-09-19T04:39:59.239Z","comments":true,"path":"2021/09/19/更换主题/","link":"","permalink":"https://stoprain0.github.io.git/2021/09/19/%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98/","excerpt":"","text":"时间：2021/9/19 更换主题 继创建了自己的博客后，应用了比较出名的二次元主题 Yume Shoka 主题地址： https://hexo.bootcss.com/themes/ 主题应用说明： https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/ 我的博客 经过修改对应的配置文件达到个性化的效果图 暂时修改了头像图片，了解博文的修改和发布。以此博文记录我完善博客的过程，那么就到这里吧。","categories":[{"name":"Hexo博客系列","slug":"Hexo博客系列","permalink":"https://stoprain0.github.io.git/categories/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"主题","slug":"主题","permalink":"https://stoprain0.github.io.git/tags/%E4%B8%BB%E9%A2%98/"},{"name":"Yume Shaka","slug":"Yume-Shaka","permalink":"https://stoprain0.github.io.git/tags/Yume-Shaka/"}]},{"title":"第一个文章","slug":"hello-world","date":"2021-09-16T12:50:59.617Z","updated":"2021-09-19T04:42:10.341Z","comments":true,"path":"2021/09/16/hello-world/","link":"","permalink":"https://stoprain0.github.io.git/2021/09/16/hello-world/","excerpt":"","text":"时间：2021/9/16 创建博客 成功通过 git 软件引用 Hexo 框架创建好博客。","categories":[{"name":"Hexo博客系列","slug":"Hexo博客系列","permalink":"https://stoprain0.github.io.git/categories/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://stoprain0.github.io.git/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://stoprain0.github.io.git/tags/Hexo/"}]}],"categories":[{"name":"C语言","slug":"C语言","permalink":"https://stoprain0.github.io.git/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"前端","slug":"前端","permalink":"https://stoprain0.github.io.git/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Java系列","slug":"Java系列","permalink":"https://stoprain0.github.io.git/categories/Java%E7%B3%BB%E5%88%97/"},{"name":"git","slug":"git","permalink":"https://stoprain0.github.io.git/categories/git/"},{"name":"数据库系列","slug":"数据库系列","permalink":"https://stoprain0.github.io.git/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97/"},{"name":"Hexo博客系列","slug":"Hexo博客系列","permalink":"https://stoprain0.github.io.git/categories/Hexo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://stoprain0.github.io.git/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"HTML","slug":"HTML","permalink":"https://stoprain0.github.io.git/tags/HTML/"},{"name":"前端","slug":"前端","permalink":"https://stoprain0.github.io.git/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Java","slug":"Java","permalink":"https://stoprain0.github.io.git/tags/Java/"},{"name":"git学习","slug":"git学习","permalink":"https://stoprain0.github.io.git/tags/git%E5%AD%A6%E4%B9%A0/"},{"name":"git命令语句","slug":"git命令语句","permalink":"https://stoprain0.github.io.git/tags/git%E5%91%BD%E4%BB%A4%E8%AF%AD%E5%8F%A5/"},{"name":"数据库","slug":"数据库","permalink":"https://stoprain0.github.io.git/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL","slug":"SQL","permalink":"https://stoprain0.github.io.git/tags/SQL/"},{"name":"主题","slug":"主题","permalink":"https://stoprain0.github.io.git/tags/%E4%B8%BB%E9%A2%98/"},{"name":"Yume Shaka","slug":"Yume-Shaka","permalink":"https://stoprain0.github.io.git/tags/Yume-Shaka/"},{"name":"博客","slug":"博客","permalink":"https://stoprain0.github.io.git/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://stoprain0.github.io.git/tags/Hexo/"}]}